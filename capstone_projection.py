# -*- coding: utf-8 -*-
"""capstone_projection.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ld5QY4GNxuE8A3X6BRTKo0HP2sXxdIem

#Import Library
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import StandardScaler
from sklearn.cluster import KMeans
from sklearn.metrics import silhouette_score

"""#Data Understanding"""

!curl -L -o onlineritel.zip\
  https://www.kaggle.com/api/v1/datasets/download/yasserh/customer-segmentation-dataset

!unzip -q /content/onlineritel.zip

df = pd.read_excel('Online Retail.xlsx')
df.head(10)

df.info()

df.describe()

"""### Cek jumlah transaksi, jumlah pelanggan unik"""

num_transactions = df.shape[0]
num_unique_customers = df['CustomerID'].nunique()

print(f"Number of transactions: {num_transactions}")
print(f"Number of unique customers: {num_unique_customers}")

"""### Cek nilai hilang"""

print("Missing values:")
display(df.isnull().sum())

"""### nilai anomali (misal harga negatif, quantities negatif)"""

negative_quantity = df[df['Quantity'] < 0]
negative_price = df[df['UnitPrice'] < 0]

print(f"Number of transactions with negative quantity: {len(negative_quantity)}")
print(f"Number of transactions with negative UnitPrice: {len(negative_price)}")

if not negative_quantity.empty:
    print("\nExamples of transactions with negative quantity:")
    display(negative_quantity.head())

if not negative_price.empty:
    print("\nExamples of transactions with negative UnitPrice:")
    display(negative_price.head())

"""### Cek rentang tanggal transaksi"""

min_date = df['InvoiceDate'].min()
max_date = df['InvoiceDate'].max()

print(f"Transaction date range: {min_date} to {max_date}")

"""#Data Cleaning

###Hapus canceled order (Quantity < 0)
"""

df = df[df['Quantity'] > 0]
print(f"New shape after removing negative quantities: {df.shape}")
display(df.head())

"""###Hapus baris tanpa CustomerID"""

df.dropna(subset=['CustomerID'], inplace=True)
print(f"New shape after removing rows with missing CustomerID: {df.shape}")
display(df.head())

"""###Hapus harga negatif"""

df = df[df['UnitPrice'] >= 0]
print(f"New shape after removing negative UnitPrice: {df.shape}")
display(df.head())

"""###Tangani missing value"""

df.dropna(subset=['Description'], inplace=True)
print(f"New shape after removing rows with missing Description: {df.shape}")
display(df.head())

"""###Hapus transaksi non-retail (misal kode item aneh)"""

non_retail_stock_codes = [
    'POST', 'D', 'M', 'CRUK', 'BANK CHARGES', 'AMAZONFEE', 'S', 'DOT',
    'ADJUST', 'BOUNCE', 'TEST', 'DCGSSBOY', 'DCGSSGIRL', 'PADS', 'B'
]
df = df[~df['StockCode'].isin(non_retail_stock_codes)]
print(f"New shape after removing non-retail transactions: {df.shape}")
display(df.head())

"""#Feature Engineering: Hitung RFM

###Menghitung Total Price
"""

df['TotalPrice'] = df['Quantity'] * df['UnitPrice']
print(f"New shape after adding TotalPrice column: {df.shape}")
display(df.head())

"""###Referensikan Tanggal

"""

import datetime as dt

latest_date = df['InvoiceDate'].max()
reference_date = latest_date + dt.timedelta(days=1)

print(f"Latest InvoiceDate: {latest_date}")
print(f"Reference Date for RFM: {reference_date}")

"""###Menghitung Recency

"""

last_purchase_date = df.groupby('CustomerID')['InvoiceDate'].max()
recency = (reference_date - last_purchase_date).dt.days

rfm_df = pd.DataFrame(recency).reset_index()
rfm_df.columns = ['CustomerID', 'Recency']

print("Recency calculated:")
display(rfm_df.head())
print(rfm_df.describe())

"""###Menghitung Frequency"""

frequency = df.groupby('CustomerID')['InvoiceNo'].nunique()
frequency = pd.DataFrame(frequency).reset_index()
frequency.columns = ['CustomerID', 'Frequency']

rfm_df = pd.merge(rfm_df, frequency, on='CustomerID')

print("Frequency calculated:")
display(rfm_df.head())
print(rfm_df.describe())

"""###Menghitung Monetary"""

monetary = df.groupby('CustomerID')['TotalPrice'].sum()
monetary = pd.DataFrame(monetary).reset_index()
monetary.columns = ['CustomerID', 'Monetary']

rfm_df = pd.merge(rfm_df, monetary, on='CustomerID')

print("Monetary calculated:")
display(rfm_df.head())
print(rfm_df.describe())

"""#Understanding RFM

###Statistik RFM
"""

print("RFM Statistics:")
display(rfm_df.describe())

"""###Korelasi antar fitur"""

plt.figure(figsize=(8, 6))
sns.heatmap(rfm_df[['Recency', 'Frequency', 'Monetary']].corr(), annot=True, cmap='coolwarm', fmt=".2f")
plt.title('Correlation Matrix of RFM Features')
plt.show()

"""###Visualisasi distribusi (histogram / boxplot)"""

plt.figure(figsize=(15, 5))

plt.subplot(1, 3, 1)
sns.histplot(rfm_df['Recency'], kde=True)
plt.title('Distribution of Recency')

plt.tight_layout()
plt.show()

plt.subplot(1, 3, 2)
sns.histplot(rfm_df['Frequency'], kde=True)
plt.title('Distribution of Frequency')

plt.tight_layout()
plt.show()

plt.subplot(1, 3, 3)
sns.histplot(rfm_df['Monetary'], kde=True)
plt.title('Distribution of Monetary')

plt.tight_layout()
plt.show()

"""#Visualisasi Setelah RFM"""

revenue_per_country = df.groupby('Country')['TotalPrice'].sum().reset_index()
revenue_per_country = revenue_per_country.sort_values(by='TotalPrice', ascending=False)

print("Total revenue per country:")
display(revenue_per_country.head())
print(revenue_per_country.describe())

top_10_countries = revenue_per_country.head(10)

print("Top 10 countries by revenue:")
display(top_10_countries)

plt.figure(figsize=(12, 6))
sns.barplot(x='Country', y='TotalPrice', data=top_10_countries, palette='viridis')
plt.title('Top 10 Countries by Revenue')
plt.xlabel('Country')
plt.ylabel('Total Revenue')
plt.xticks(rotation=45, ha='right')
plt.grid(axis='y')
plt.tight_layout()
plt.show()

df['InvoiceMonth'] = df['InvoiceDate'].dt.to_period('M')
revenue_per_month = df.groupby('InvoiceMonth')['TotalPrice'].sum().reset_index()
revenue_per_month['InvoiceMonth'] = revenue_per_month['InvoiceMonth'].dt.to_timestamp()

plt.figure(figsize=(12, 6))
sns.lineplot(x='InvoiceMonth', y='TotalPrice', data=revenue_per_month, marker='o')
plt.title('Revenue Trend Per Month')
plt.xlabel('Month')
plt.ylabel('Total Revenue')
plt.grid(True)
plt.tight_layout()
plt.show()

df['DayOfWeek'] = df['InvoiceDate'].dt.day_name()
df['HourOfDay'] = df['InvoiceDate'].dt.hour

# Order days of the week correctly
day_order = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
df['DayOfWeek'] = pd.Categorical(df['DayOfWeek'], categories=day_order, ordered=True)

# Create a pivot table for the heatmap
heatmap_data = df.groupby(['DayOfWeek', 'HourOfDay']).size().unstack(fill_value=0)

plt.figure(figsize=(15, 8))
sns.heatmap(heatmap_data, cmap='viridis', fmt='d', linewidths=.5, linecolor='black')
plt.title('Heatmap of Transactions by Day of Week and Hour of Day')
plt.xlabel('Hour of Day')
plt.ylabel('Day of Week')
plt.tight_layout()
plt.show()

# Get unique CustomerID and Country mapping from the main DataFrame
customer_country_mapping = df[['CustomerID', 'Country']].drop_duplicates()

# Merge rfm_df with the customer_country_mapping to get country for each customer
rfm_with_country = pd.merge(rfm_df, customer_country_mapping, on='CustomerID', how='left')

# Calculate the average Recency and Monetary for each country
country_rfm_avg = rfm_with_country.groupby('Country')[['Recency', 'Monetary']].mean().reset_index()

# Create the scatter plot
plt.figure(figsize=(14, 9))
sns.scatterplot(data=country_rfm_avg, x='Recency', y='Monetary', hue='Country', size='Monetary', sizes=(50, 1000), alpha=0.7)
plt.title('Distribution of Average Monetary vs Average Recency per Country')
plt.xlabel('Average Recency (Days since last purchase)')
plt.ylabel('Average Monetary (Total Revenue per Customer)')
plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left', borderaxespad=0.)
plt.grid(True)
plt.tight_layout()
plt.show()

"""#Preprocessing untuk Clustering

###Standardisasi fitur (MinMaxScaler / StandardScaler)
"""

rfm_scaled = rfm_df[['Recency', 'Frequency', 'Monetary']].copy()
scaler = StandardScaler()
rfm_scaled = scaler.fit_transform(rfm_scaled)

rfm_scaled_df = pd.DataFrame(rfm_scaled, columns=['Recency_Scaled', 'Frequency_Scaled', 'Monetary_Scaled'])
rfm_scaled_df['CustomerID'] = rfm_df['CustomerID']

print("Scaled RFM features:")
display(rfm_scaled_df.head())
print(rfm_scaled_df.describe())

"""###Cek outlier"""

plt.figure(figsize=(15, 5))

plt.subplot(1, 3, 1)
sns.boxplot(y=rfm_scaled_df['Recency_Scaled'])
plt.title('Box Plot of Recency (Scaled)')

plt.tight_layout()
plt.show()

plt.subplot(1, 3, 2)
sns.boxplot(y=rfm_scaled_df['Frequency_Scaled'])
plt.title('Box Plot of Frequency (Scaled)')

plt.tight_layout()
plt.show()

plt.subplot(1, 3, 3)
sns.boxplot(y=rfm_scaled_df['Monetary_Scaled'])
plt.title('Box Plot of Monetary (Scaled)')

plt.tight_layout()
plt.show()

"""###Addressing Outliers with Log Transformation"""

import numpy as np

# Apply log transformation (using log1p to handle potential zero values gracefully)
rfm_log_transformed = rfm_df[['Recency', 'Frequency', 'Monetary']].apply(lambda x: np.log1p(x))

print("RFM features after log transformation:")
display(rfm_log_transformed.head())
print(rfm_log_transformed.describe())

"""###Re-scaling Log-Transformed Features"""

scaler_log = StandardScaler()
rfm_scaled_log = scaler_log.fit_transform(rfm_log_transformed)

rfm_scaled_log_df = pd.DataFrame(rfm_scaled_log, columns=['Recency_Scaled_Log', 'Frequency_Scaled_Log', 'Monetary_Scaled_Log'])
rfm_scaled_log_df['CustomerID'] = rfm_df['CustomerID']

print("Scaled RFM features after log transformation:")
display(rfm_scaled_log_df.head())
print(rfm_scaled_log_df.describe())

"""###Re-checking Outliers with Box Plots (Log-Transformed and Scaled)"""

plt.figure(figsize=(15, 5))

plt.subplot(1, 3, 1)
sns.boxplot(y=rfm_scaled_log_df['Recency_Scaled_Log'])
plt.title('Box Plot of Recency (Scaled, Log-Transformed)')

plt.subplot(1, 3, 2)
sns.boxplot(y=rfm_scaled_log_df['Frequency_Scaled_Log'])
plt.title('Box Plot of Frequency (Scaled, Log-Transformed)')

plt.subplot(1, 3, 3)
sns.boxplot(y=rfm_scaled_log_df['Monetary_Scaled_Log'])
plt.title('Box Plot of Monetary (Scaled, Log-Transformed)')

plt.tight_layout()
plt.show()

"""#Menentukan Jumlah Cluster Optimal

###Calculate WCSS for different cluster numbers
"""

wcss = []
for k in range(1, 11):
    kmeans = KMeans(n_clusters=k, random_state=42, n_init=10)
    kmeans.fit(rfm_scaled_log_df[['Recency_Scaled_Log', 'Frequency_Scaled_Log', 'Monetary_Scaled_Log']])
    wcss.append(kmeans.inertia_)

print("WCSS values for k from 1 to 10:")
print(wcss)

plt.figure(figsize=(10, 6))
plt.plot(range(1, 11), wcss, marker='o', linestyle='--')
plt.title('Elbow Method for Optimal K')
plt.xlabel('Number of Clusters (K)')
plt.ylabel('WCSS (Within-Cluster Sum of Squares)')
plt.xticks(range(1, 11))
plt.grid(True)

# Adding a label for the suggested optimal k
optimal_k = 4 # Based on visual inspection of the elbow curve
plt.axvline(x=optimal_k, color='r', linestyle=':', label=f'Optimal K = {optimal_k}')
plt.legend()
plt.show()

"""#Clustering (K-Means)

###Train K-Means Model
"""

kmeans_model = KMeans(n_clusters=optimal_k, random_state=42, n_init=10)
kmeans_model.fit(rfm_scaled_log_df[['Recency_Scaled_Log', 'Frequency_Scaled_Log', 'Monetary_Scaled_Log']])

print(f"K-Means model trained with {optimal_k} clusters.")

cluster_labels = kmeans_model.predict(rfm_scaled_log_df[['Recency_Scaled_Log', 'Frequency_Scaled_Log', 'Monetary_Scaled_Log']])
rfm_df['Cluster'] = cluster_labels
rfm_scaled_log_df['Cluster'] = cluster_labels

print("RFM DataFrame with cluster assignments:")
display(rfm_df.head())

"""###Evaluate Cluster Quality

"""

X = rfm_scaled_log_df[['Recency_Scaled_Log', 'Frequency_Scaled_Log', 'Monetary_Scaled_Log']]
labels = rfm_scaled_log_df['Cluster']

silhouette_avg = silhouette_score(X, labels)

print(f"The Silhouette Score for the clustering is: {silhouette_avg:.4f}")

"""#Business Interpretation: Nama Segmen"""

cluster_profile = rfm_df.groupby('Cluster')[['Recency', 'Frequency', 'Monetary']].mean().reset_index()
display(cluster_profile)

cluster_names = {
    0: 'At Risk Customers',
    1: 'New Customers',
    2: 'Loyal Customers',
    3: 'Big Spenders'
}

rfm_df['Cluster_Name'] = rfm_df['Cluster'].map(cluster_names)

print("Cluster profiles with assigned persona names:")
display(rfm_df.groupby('Cluster_Name')[['Recency', 'Frequency', 'Monetary']].mean().sort_values(by='Recency', ascending=True))

print("RFM DataFrame with Cluster and Persona Names:")
display(rfm_df.head())

"""#Visualisasi Segmentasi"""

plt.figure(figsize=(10, 8))
sns.scatterplot(data=rfm_df, x='Recency', y='Frequency', hue='Cluster_Name', palette='viridis', s=100, alpha=0.7)
plt.title('Customer Segments: Recency vs Frequency')
plt.xlabel('Recency (Days since last purchase)')
plt.ylabel('Frequency (Number of purchases)')
plt.legend(title='Customer Persona', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.grid(True)
plt.tight_layout()
plt.show()

plt.figure(figsize=(10, 6))
sns.countplot(data=rfm_df, x='Cluster_Name', palette='viridis', order=rfm_df['Cluster_Name'].value_counts().index)
plt.title('Number of Members per Cluster')
plt.xlabel('Customer Persona')
plt.ylabel('Number of Members')
plt.xticks(rotation=45, ha='right')
plt.grid(axis='y')
plt.tight_layout()
plt.show()

from math import pi

# Get cluster profiles (average RFM values)
cluster_profile = rfm_df.groupby('Cluster_Name')[['Recency', 'Frequency', 'Monetary']].mean().reset_index()

# Normalize RFM values for radar chart (scaling to 0-1 or similar range)
# A simple min-max scaling for each feature independently
cluster_profile_normalized = cluster_profile.copy()
for col in ['Recency', 'Frequency', 'Monetary']:
    min_val = cluster_profile_normalized[col].min()
    max_val = cluster_profile_normalized[col].max()
    # Recency is better when lower, so invert its scale
    if col == 'Recency':
        cluster_profile_normalized[col] = (max_val - cluster_profile_normalized[col]) / (max_val - min_val)
    else:
        cluster_profile_normalized[col] = (cluster_profile_normalized[col] - min_val) / (max_val - min_val)

# Number of variables
categories = ['Recency', 'Frequency', 'Monetary']
N = len(categories)

# What angle for each category?
angles = [n / float(N) * 2 * pi for n in range(N)]
angles += angles[:1]

# Plot each cluster
fig = plt.figure(figsize=(10, 10))
ax = fig.add_subplot(111, polar=True)

# Helper to reverse 'Recency' interpretation for plotting
def get_values_for_plot(row, categories):
    values = row[categories].tolist()
    values += values[:1]
    return values

for i, row in cluster_profile_normalized.iterrows():
    values = get_values_for_plot(row, categories)
    ax.plot(angles, values, linewidth=2, linestyle='solid', label=row['Cluster_Name'])
    ax.fill(angles, values, alpha=0.25)

# Draw one axe per variable + add labels
plt.xticks(angles[:-1], categories, color='grey', size=12)

# Draw ylabels
ax.set_rlabel_position(0)
plt.yticks([0.25, 0.5, 0.75, 1], ["0.25", "0.50", "0.75", "1.00"], color="grey", size=10)
plt.ylim(0, 1)

plt.title('Customer Segment Profiles (Radar Chart)', size=16, color='black', y=1.1)
plt.legend(loc='upper right', bbox_to_anchor=(1.3, 1.1))
plt.tight_layout()
plt.show()

"""#Rekomendasi Strategi Marketing

### Rekomendasi Strategi Pemasaran Berdasarkan Segmen Pelanggan

Berdasarkan karakteristik Recency, Frequency, dan Monetary (RFM) dari tiap segmen pelanggan, berikut adalah rekomendasi strategi pemasaran yang dapat diimplementasikan:

*   **Big Spenders (Cluster 1)**
    *   **Karakteristik:** Pelanggan yang paling sering berbelanja, menghabiskan uang paling banyak, dan paling baru melakukan pembelian.
    *   **Strategi:**
        *   **VIP Program:** Tawarkan program loyalitas eksklusif dengan reward yang menarik, akses awal ke produk baru, atau diskon khusus.
        *   **Personalized Recommendations:** Berikan rekomendasi produk yang sangat personal berdasarkan riwayat pembelian mereka yang sering dan bernilai tinggi.
        *   **Premium Customer Service:** Sediakan layanan pelanggan prioritas untuk memastikan pengalaman belanja yang luar biasa.

*   **Loyal Customers (Cluster 2)**
    *   **Karakteristik:** Pelanggan yang cukup sering berbelanja dan baru-baru ini melakukan pembelian, namun dengan nilai transaksi yang moderat.
    *   **Strategi:**
        *   **Retention Programs:** Fokus pada mempertahankan loyalitas mereka melalui poin reward, diskon berkala, atau penawaran khusus untuk pembelian berulang.
        *   **Engagement Campaigns:** Kirimkan newsletter atau konten menarik yang relevan dengan minat mereka untuk menjaga hubungan.
        *   **Upselling/Cross-selling:** Promosikan produk pelengkap atau versi premium dari produk yang sering mereka beli.

*   **At Risk Customers (Cluster 0)**
    *   **Karakteristik:** Pelanggan yang memiliki frekuensi dan nilai transaksi moderat, tetapi sudah cukup lama tidak berbelanja (recency tinggi).
    *   **Strategi:**
        *   **Re-engagement Campaigns:** Kirimkan penawaran diskon khusus atau insentif untuk mendorong pembelian kembali.
        *   **Win-back Offers:** Tawarkan produk gratis atau bonus untuk pembelian berikutnya.
        *   **Feedback Survey:** Ajak mereka mengisi survei untuk mengetahui alasan mereka tidak aktif dan bagaimana cara memperbaikinya.

*   **New Customers (Cluster 3)**
    *   **Karakteristik:** Pelanggan yang baru melakukan satu atau dua pembelian dan mungkin dengan nilai transaksi yang relatif kecil, serta sudah cukup lama tidak berbelanja.
    *   **Strategi:**
        *   **Welcome Offers:** Berikan diskon khusus untuk pembelian pertama atau kedua untuk mendorong eksplorasi lebih lanjut.
        *   **Onboarding Campaign:** Kirimkan panduan penggunaan produk, tips & trik, atau informasi relevan lainnya untuk membantu mereka mendapatkan nilai dari pembelian awal mereka.
        *   **Building Relationship:** Ajak mereka bergabung dengan komunitas atau program loyalitas dasar untuk mulai membangun hubungan jangka panjang.
"""